use assembly = 'System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'

use namespace = 'System'
use namespace = 'System.IO'
use namespace = 'System.Linq'

use import = 'Condo.Build'
use import = 'Condo.AssemblyInfo'

default base_path           = '${ Build.Get("BUILD_SOURCESDIRECTORY", Directory.GetCurrentDirectory()) }'

default target_path         = '${ Build.Get("BUILD_BINARIESDIRECTORY", Path.Combine(base_path, "artifacts")) }'
default bin_path            = '${ Path.Combine(base_path, "bin") }'
default src_path            = '${ Path.Combine(base_path, "src") }'
default test_path           = '${ Path.Combine(base_path, "test") }'
default working_path        = '${ base_path }'
default appdata_path        = '${ Build.Get("AGENT_BUILDDIRECTORY", Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)) }'

default nuget_cache_path    = '${ Path.Combine(appdata_path, "nuget", "packages") }'

default target_build_path   = '${ Path.Combine(target_path, "build") }'
default target_test_path    = '${ Build.Get("COMMON_TESTRESULTSDIRECTORY", Path.Combine(target_path, "test")) }'
default target_package_path = '${ Path.Combine(target_path, "packages") }'

default version             = '${ Build.Get("BUILD_VERSION", "1.0.0") }'
default configuration       = '${ Build.Get("CONFIGURATION", "Debug") }'
default platform            = '${ Build.Get("PLATFORM", "Any CPU") }'

default Coverage            = '${ false }'

@{
    // set the log instance on the helper class
    Build.Log = new QuietLog(this.Log, false);

    // replace the current instance of the logger with the one that handles "quiet"
    this.Log = Build.Log;

    if (!string.IsNullOrEmpty(version))
    {
        // set the assembly version
        AssemblyInfo.AssemblyVersion = version;
    }

    // determine if the src path was overwritten without using a fully-qualified path
    if (!src_path.Contains(Path.DirectorySeparatorChar) && !src_path.Contains(Path.AltDirectorySeparatorChar))
    {
        // make src path a fully qualified path
        src_path = Path.Combine(base_path, src_path);
    }

    // determine if the test path was overwritten without using a fully-qualified path
    if (!test_path.Contains(Path.DirectorySeparatorChar) && !test_path.Contains(Path.AltDirectorySeparatorChar))
    {
        // make the test path a fully qualified path
        test_path = Path.Combine(base_path, test_path);
    }

    // set secure logging if build is CI
    Build.Log.Secure = Build.CI;
}

info-collect once='info-collect'
environment once='environment'

@{
    Build.Log.Secure = false;

    Build.Log.Header();
    Build.Log.Header("paths");
    Build.Log.Argument("base path", base_path);
    Build.Log.Argument("source path", src_path);
    Build.Log.Argument("test path", test_path);
    Build.Log.Argument("working path", working_path);
    Build.Log.Argument("bin path", bin_path);
    Build.Log.Argument("target path", target_path);

    Build.Log.Argument("build results path", target_build_path);
    Build.Log.Argument("test results path", target_test_path);
    Build.Log.Argument("nuget packages path", target_package_path);
    Build.Log.Header();

    Build.Log.Header("options");
    Build.Log.Argument("configuration", string.IsNullOrEmpty(configuration) ? "<All>" : configuration);
    Build.Log.Argument("version", AssemblyInfo.AssemblyVersion);
    Build.Log.Argument("date time (utc)", AssemblyInfo.BuildDateUtc);
    Build.Log.Argument("quiet", Build.Log.Quiet);
    Build.Log.Header();
}

#--quiet @{
    Build.Log.Quiet = true;
}

#--secure @{
    Build.Log.Secure = true;
}

#--coverage @{
    Coverage = true;
}

#-q .--quiet

#clean-bin description='Cleans the bin directory.' -Build.RemoveDirectory(bin_path);

#clean-nuget-packages description='Cleans NuGet package directory.' @{
    Build.Log.Header("clean-nuget-packages");

    var path = Path.Combine(base_path, "packages");

    if (Directory.Exists(path))
    {
        Build.Log.Argument("path", path);

        var packages = Directory.GetDirectories(path)
            .Where(p => !p.EndsWith("PulseBridge.Condo"))
            .Where(p => !p.EndsWith("Sake"));

        foreach (var package in packages)
        {
            Build.Log.Argument("package path", package);
            Build.RemoveDirectory(package);
        }
    }

    Build.Log.Header();
}

#clean-npm-modules description='Cleans any installed NPM modules.' @{
    Build.Log.Header("clean-npm-modules");

    var paths = Build.GetPathsContaining(base_path, "package.json")
        .Select(p => Path.Combine(p, "node_modules"))
        .Where(p => Directory.Exists(p));

    foreach (var path in paths)
    {
        Build.Log.Argument("path", path);
        Build.RemoveDirectory(path);
    }

    var node_path = Path.Combine(base_path, "node_modules");

    if (Directory.Exists(node_path))
    {
        Build.Log.Argument("path", node_path);
        Build.RemoveDirectory(node_path);
    }

    Build.Log.Header();
}

#clean-bower-components description='Cleans any installed bower components.' @{
    Build.Log.Header("clean-bower-components");

    var paths = Build.GetPathsContaining(base_path, "bower.json")
        .Select(p => Path.Combine(p, "bower_components")).Where(p => Directory.Exists(p));

    foreach (var path in paths)
    {
        Build.Log.Argument("path", path);
        Build.RemoveDirectory(path);
    }

    var bower_path = Path.Combine(base_path, "bower_components");

    if (Directory.Exists(bower_path))
    {
        Build.Log.Argument("path", bower_path);
        Build.RemoveDirectory(bower_path);
    }

    Build.Log.Header();
}

#clean-artifacts target='clean' description='Cleans the artifacts directory from the working directory.' -Build.RemoveDirectory(target_path);

#clean-build target='clean' description='Clean the build artifacts from each project within the working directory.'
    var paths = '${ Build.GetPathsContaining(src_path, "project.json")
        .Union(Build.GetPathsContaining(test_path, "project.json"))
        .Union(Build.GetPathsContaining(src_path, "*.csproj"))
        .Union(Build.GetPathsContaining(test_path, "*.csproj")) }'
    dotnet-clean each='var dotnet_clean_path in paths'

#clean-all .clean-bower-components .clean-npm-modules .clean-bin .clean-nuget-packages .clean description='Clean everything in preparation for `git clean`.'

#restore-npm-modules description='Restores all NPM modules. This will install NodeJS and NPM if not already found on the system.'
    var paths = '${ Build.GetPathsContaining(base_path, "package.json") }'
    npm-install each='var npm_install_path in paths'

#restore-bower-components description='Restores all Bower components. This will install the Bower node module if not already found on the system.'
    var paths = '${ Build.GetPathsContaining(base_path, "bower.json") }'
    bower-install each='var bower_install_path in paths'

#restore-gems description='Restores all gems specified in a Gemfile.'
    var paths = '${ Build.GetPathsContaining(base_path, "Gemfile").Union(Build.GetPathsContaining(base_path, "gemfile")) }'
    bundle-install each='var bundle_install_path in paths'

#restore-tsd-definitions description='Restores TypeScript definitions.'
    var paths = '${ Build.GetPathsContaining(base_path, "tsd.json") }'
    for each='var tsd_path in paths'
        tsd tsd_args='reinstall --clean --overwrite --save'
        tsd tsd_args='link'
        tsd tsd_args='rebundle'

#restore-project-packages description='Restores all NuGet packages (project.json).'
    var paths = '${ Build.GetPathsContaining(base_path, "project.json") }'
    dotnet-restore each='var dotnet_restore_path in paths'

#restore-nuget-packages description='Restores all NuGet packages (packages.config).'
    var paths = '${ Build.GetPathsContaining(src_path, "packages.config").Union(Build.GetPathsContaining(test_path, "packages.config")) }'
    nuget-restore each='var nuget_restore_path in paths'

#restore-packages .restore-project-packages .restore-nuget-packages .restore-tsd-definitions .restore-npm-modules .restore-bower-components .restore-gems target='restore' description='Restores all NuGet packages, Bower components, and NPM modules.'

#initialize-grunt description='Initializes the project by executing the default grunt task. This will install the grunt node module if not already found on the system.'
    var paths = '${ Build.GetPathsContaining(base_path, "gruntfile.js") }'
    grunt each='var grunt_path in paths'

#initialize-gulp description='Initializes the project by executing the default gulp task. This will install the gulp node module if not already found on the system.'
    var paths = '${ Build.GetPathsContaining(base_path, "gulpfile.js").Union(Build.GetPathsContaining(base_path, "gulpfile.babel.js")).Union(Build.GetPathsContaining(base_path, "gulpfile.ts")) }'
    gulp-task each='var gulp_task_path in paths'

#validate-info target='validate' description='Collects and validates assembly information used during the build.'
    var paths = '${ Build.GetPathsContaining(base_path, "project.json") }'
    info each='var info_path in paths'

#initialize-all .initialize-grunt .initialize-gulp target='initialize' description='Initializes all initialization targets.'

#compile-dotnet target='compile' description='Compiles and packages all dotnet-based projects found within the source directory.'
    var paths = '${ Build.GetPathsContaining(src_path, "project.json") }'
    dotnet-pack dotnet_pack_output_path='${ target_build_path }' each='var dotnet_pack_path in paths'

#compile-msbuild target='compile' description='Compiles and packages all msbuild-based projects found within the source directory.'
    var paths = '${ Build.GetPaths(working_path, "condo.msbuild") }'
    msbuild each='var msbuild_project in paths'

#test-dotnet target='test' description='Executes unit tests for all dotnet-based projects found within the test directory.'
    var paths = '${ Build.GetPathsContaining(test_path, "project.json") }'
    dotnet-test dotnet_test_output_path='${ target_test_path }' each='var dotnet_test_path in paths'

#test-msbuild target='test' description='Executes unit tests for all msbuild-based projects found within the build target directory.'
    var paths = '${ Build.GetPaths(target_build_path, "*.test.dll") }'
    var tests = '${ string.Join("\" \"", paths) }'
    vstest vstest_test_path='"${ tests }"' if='!string.IsNullOrEmpty(tests)'

#test-mocha target='test' description='Executes client-side tests using mocha'
    var paths = '${ Build.GetPathsContaining(src_path, "project.json").Where(path => { var test = Path.Combine(path, "test"); return Directory.Exists(test) && Directory.GetFiles(test, "*.js").Any(); }) }'
    mocha mocha_output_path='${ target_test_path }' each='var mocha_path in paths'

#test-compile-dotnet target='compile' description='Compiles dotnet-based projects found within the test directory.'
    var paths = '${ Build.GetPathsContaining(test_path, "project.json") }'
    dotnet-build dotnet_build_output_path='${ target_test_path }' each='var dotnet_build_path in paths'

#test-coverage-dotnet target='test-coverage' description='Generates a code coverage report for dotnet-based projects'
    dotnet-cover-report if='Coverage'

#pack-nuget-packages target='package' description='Packages NuGet specifications found within the source directory.'
    var specs = '${ Build.GetPathsContaining(src_path, "*.nuspec") }'
    nuget-pack nuget_pack_output_path='${ target_package_path }' each='var nuget_pack_path in specs'

#push-nuget-packages-local target='post-package' description='Pushes NuGet packages to the local feed for development purposes.' if='Directory.Exists(target_package_path)'
    copy copy_src_path='${ target_package_path }' copy_dst_path='${ nuget_cache_path }' copy_include="**/*.nupkg" copy_exclude="**/*.symbols.nupkg" copy_overwrite='${ true }' copy_flatten='${ true }'

#push-dotnet-packages-local target='post-package' description='Pushes dotnet packages to the local feed for development purposes.' if='Directory.Exists(target_build_path)'
    copy copy_src_path='${ target_build_path }' copy_dst_path='${ nuget_cache_path }' copy_include="**/*.nupkg" copy_exclude="**/*.symbols.nupkg" copy_overwrite='${ true }' copy_flatten='${ true }'

#push-nuget-packages target='push' description='Pushes NuGet packages to a NuGet feed.'
    var pkgs = '${ Build.GetPaths(target_package_path, "*.nupkg").Where(pkg => !pkg.EndsWith(".symbols.nupkg") && !pkg.EndsWith(".deploy.nupkg")) }'
    nuget-push each='var nuget_push_package in pkgs'

#push-nuget-symbols target='push' description='Pushes NuGet symbol packages to a NuGet feed.'
    var pkgs = '${ Build.GetPaths(target_package_path, "*.symbols.nupkg") }'
    nuget-push-symbols each='var nuget_push_package in pkgs'

#push-deploy-packages target='deploy' description='Pushes NuGet packages for Octopus Deploy to a NuGet feed.'
    var pkgs = '${ Build.GetPaths(target_package_path, "*.deploy.nupkg") }'
    nuget-push-deploy each='var nuget_deploy_package in pkgs'

#push-dotnet-packages target='push' description='Pushes dotnet packages to a NuGet feed.'
    var pkgs = '${ Build.GetPaths(target_build_path, "*.nupkg").Where(pkg => !pkg.EndsWith(".symbols.nupkg") && !pkg.EndsWith(".deploy.nupkg")) }'
    nuget-push each='var nuget_push_package in pkgs'

#run-dotnet target='run' description='Runs any dotnet projects that contain a command for execution based on the platform.'
    var paths = '${ Build.GetPathsContaining(src_path, "project.json") }'
    dotnet-run each='var dotnet_run_project in paths'

#watch-dotnet target='watch' description='Runs and watches any dotnet projects that contain a command for execution based on the platform.'
    var paths = '${ Build.GetPathsContaining(src_path, "project.json") }'
    dotnet-watch each='var dotnet_watch_project in paths'