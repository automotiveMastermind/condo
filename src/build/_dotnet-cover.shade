@{/*

dotnet-cover
    Collects code coverage results for the specified target process or service.

dotnet_cover_target=''
    Required. The target process for which to collect code coverage results.

dotnet_cover_args=''
    The arguments to pass to the code coverage target.

dotnet_cover_options='-nodefaultfilters -hideskipped:All -threshold:1'
    Additional options to pass to the code coverage process.

dotnet_cover_exclude_files=''
    A semi-colon (;) delimited list of file name globbing patterns that will be excluded from code coverage results.

dotnet_cover_exclude_attributes='*.ExcludeFromCodeCoverage*'
    A semi-colon (;) delimited list of attribute name globbing patterns that will be excluded from code coverage results.

dotnet_cover_filter='+[*]* -[*.Tests]* -[*.Test]*'
    A semi-colon (;) delimited list of PartCover filters used to include or exclude assemblies, classes, and methods from code coverage results.

dotnet_cover_register='user'
    Determines the level of registration of the code coverage profiler.

dotnet_cover_show_unvisited='${ false }'
    A value indicating whether or not to list unvisted methods and classes once the coverage analysis is complete.

dotnet_cover_skip_autoprops='${ true }'
    A value indicating whether or not to skip code coverage of automatic properties.

dotnet_cover_path='$(working_path)'
    The path in which to execute the cover command line tool.

dotnet_dotnet_cover_pdb_path='$(target_test_path)'
    The path containing the PDBs used to evaluate code coverage.

dotnet_cover_output_path='$(target_test_path)'
    The path where the code coverage results should be stored.

dotnet_cover_wait='true'
    A value indicating whether or not to wait for exit.

dotnet_cover_quiet='$(Build.Log.Quiet)'
    A value indicating whether or not to avoid printing output.

base_path='$(CurrentDirectory)'
    The base path in which to execute the code coverage tool.

working_path='$(base_path)'
    The working path in which to execute the code coverage tool.

target_path='$(base_path)/artifacts'
    The path where build artifacts and results should be stored.

target_test_path='$(target_path)/test'
    The path where test results should be stored.

*/}

use namespace = 'System'
use namespace = 'System.IO'

use import = 'Condo.Build'

dnvm-locate once='dnvm-locate'

default base_path                           = '${ Directory.GetCurrentDirectory() }'
default working_path                        = '${ base_path }'
default target_path                         = '${ Build.Get("BUILD_BINARIESDIRECTORY", Path.Combine(base_path, "artifacts")) }'
default target_test_path                    = '${ Build.Get("COMMON_TESTRESULTSDIRECTORY", Path.Combine(target_path, "test")) }'
default dnvm_path                           = '${ Build.GetPath("dnvm").Path }'

default dotnet_cover_target                 = ''
default dotnet_cover_pdb_path               = ''
default dotnet_cover_args                   = ''
default dotnet_cover_options                = '-nodefaultfilters -hideskipped:All -threshold:1'
default dotnet_cover_exclude_files          = ''
default dotnet_cover_exclude_attributes     = '*.ExcludeFromCodeCoverage*'
default dotnet_cover_filter                 = '+[*]* -[Xunit]* -[Xunit.*]* -[xunit]* -[xunit.*]*'
default dotnet_cover_register               = 'user'
default dotnet_cover_show_unvisited         = '${ false }'
default dotnet_cover_skip_autoprops         = '${ true }'
default dotnet_cover_output_path            = '${ target_test_path }'
default dotnet_cover_path                   = '${ working_path }'
default dotnet_cover_wait                   = '${ true }'
default dotnet_cover_quiet                  = '${ Build.Log.Quiet }'
default dotnet_cover_install_path           = '${ Path.Combine(base_path, "packages") }'
default dotnet_cover_runtime                = ''

var cover_id                                = 'OpenCover'
var cover_exe                               = 'OpenCover.Console.exe'
var cover_install                           = '${ Path.Combine(dotnet_cover_install_path, cover_id, "tools", cover_exe) }'
var cover_exec_cmd                          = ''
var cover_where_cmd                         = ''

nuget-install nuget_install_id='${ cover_id }' nuget_install_exclude_version='${ true }' if='!File.Exists(cover_install) && !Build.Unix' nuget_install_prerelease='${ true }' once='cover-install'

@{
    Build.Log.Header("dotnet-cover");

    if (string.IsNullOrEmpty(dotnet_cover_target))
    {
        if (!string.IsNullOrEmpty(dotnet_cover_runtime))
        {
            if (Build.Unix)
            {
                cover_exec_cmd = '/usr/bin/env';
                cover_where_cmd = string.Format(@"bash -c 'source ""{0}"" && dnvm use {1} 1>/dev/null 2>&1 && which dnx' 2>/dev/null", dnvm_path, dotnet_cover_runtime);
            }
            else
            {
                cover_exec_cmd = dnvm_path;
                cover_where_cmd = string.Format(@"use {0} 1>nul 2>&1 && where dnx", dotnet_cover_runtime);
            }
        }

        Build.TryExecute(cover_exec_cmd, out dotnet_cover_target, cover_where_cmd);
    }

    if (string.IsNullOrEmpty(dotnet_cover_target))
    {
        throw new ArgumentNullException("dotnet-cover: dotnet_cover_target must be specified.", "dotnet_cover_target");
    }

    Build.MakeDirectory(Path.GetDirectoryName(dotnet_cover_output_path));

    Build.Log.Argument("target", dotnet_cover_target);
    Build.Log.Argument("runtime", dotnet_cover_runtime);
    Build.Log.Argument("arguments", dotnet_cover_args);
    Build.Log.Argument("options", dotnet_cover_options);
    Build.Log.Argument("excluded files", dotnet_cover_exclude_files);
    Build.Log.Argument("excluded attrs", dotnet_cover_exclude_attributes);
    Build.Log.Argument("filter", dotnet_cover_filter);
    Build.Log.Argument("target path", dotnet_cover_path);
    Build.Log.Argument("output path", dotnet_cover_output_path);
    Build.Log.Argument("pdb path", dotnet_cover_pdb_path);
    Build.Log.Argument("register", dotnet_cover_register);
    Build.Log.Argument("show unvisited", dotnet_cover_show_unvisited);
    Build.Log.Argument("skip auto-props", dotnet_cover_skip_autoprops);
    Build.Log.Argument("wait", dotnet_cover_wait);
    Build.Log.Argument("quiet", dotnet_cover_quiet);
    Build.Log.Header();

    if (Build.Unix)
    {
        Build.Log.Warn("dotnet-cover: code coverage analysis is only available on the Windows platform at the present time.");
    }
}

exec exec_cmd='${ dotnet_cover_target }' exec_args='${ dotnet_cover_args }' exec_path='${ dotnet_cover_path }' if='Build.Unix'

@{
    dotnet_cover_options = (dotnet_cover_options ?? string.Empty) + string.Format(@" -target:""{0}""", dotnet_cover_target);

    if (!string.IsNullOrEmpty(dotnet_cover_pdb_path) && dotnet_cover_target.Contains("dnx"))
    {
        dotnet_cover_args = string.Format(@" --lib {0} {1}", dotnet_cover_pdb_path, dotnet_cover_args).Trim();
    }

    if (!string.IsNullOrEmpty(dotnet_cover_args))
    {
        dotnet_cover_options += string.Format(@" -targetargs:""{0}""", dotnet_cover_args.Replace("\"", "\\\""));
    }

    if (!string.IsNullOrEmpty(dotnet_cover_exclude_files))
    {
        dotnet_cover_options += string.Format(@" -excludebyfile:""{0}""", dotnet_cover_exclude_files);
    }

    if (!string.IsNullOrEmpty(dotnet_cover_exclude_attributes))
    {
        dotnet_cover_options += string.Format(@" -excludebyattribute:""{0}""", dotnet_cover_exclude_attributes);
    }

    if (!string.IsNullOrEmpty(dotnet_cover_filter))
    {
        dotnet_cover_options += string.Format(@" -filter:""{0}""", dotnet_cover_filter);
    }

    if (!string.IsNullOrEmpty(dotnet_cover_register))
    {
        dotnet_cover_options += string.Format(@" -register:""{0}""", dotnet_cover_register);
    }

    if (!string.IsNullOrEmpty(dotnet_cover_output_path))
    {
        if (!dotnet_cover_output_path.EndsWith("xml"))
        {
            Path.Combine(dotnet_cover_output_path, "coverage.xml");
        }

        dotnet_cover_options += string.Format(@" -output:""{0}""", dotnet_cover_output_path);
    }

    if (dotnet_cover_show_unvisited)
    {
        dotnet_cover_options += " -showunvisited";
    }

    if (dotnet_cover_skip_autoprops)
    {
        dotnet_cover_options += " -skipautoprops";
    }

    dotnet_cover_options = dotnet_cover_options.Trim();
}

exec exec_cmd='${ cover_install }' exec_args='${ dotnet_cover_options }' exec_path='${ dotnet_cover_path }' exec_wait='${ dotnet_cover_wait }' exec_quiet='${ dotnet_cover_quiet }' if='!Build.Unix'